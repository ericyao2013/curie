import os

# LIBRARY FILES
sourcefiles = [ 'sexpr', 'io', 'memory-pool', 'tree', 'exec', 'multiplex',
                'immutable', 'string', 'memory-allocator', 'sexpr-library',
                'sexpr-read-write', 'network', 'multiplex-io',
                'multiplex-sexpr', 'multiplex-process', 'multiplex-signal' ]

needforstandalone = [ 'io-system', 'memory', 'bootstrap', 'network-system',
                      'exec-system', 'multiplex-system', 'signal-system' ]

sourcefiles += needforstandalone
noasm = []

# OPTIONS

opts = Options()
opts.Add(BoolOption('debug', 'build with debug information', False))
opts.Add(BoolOption('debugMemory', 'use alternative code fragments that will work with valgrind', False))
opts.Add(BoolOption('optimise', 'default optimisations', True))
opts.Add(BoolOption('optimiseLinking', 'special linker optimisations', True))
opts.Add(BoolOption('useAssembly', 'use assembler code (usually to bypass the default C library)', True))

opts.Add('arch', 'target architecture', os.uname()[4].lower())
opts.Add('computerVendor', 'computer vendor', 'unknown')
opts.Add('ostype', 'OS type', os.uname()[0].lower())
opts.Add('cctype', 'toolchain type', 'gnu')

if 'CFLAGS' in os.environ:
  opts.Add('cflags', 'additional compiler flags', os.environ['CFLAGS'])
else:
  opts.Add('cflags', 'additional compiler flags', '')

if 'LDFLAGS' in os.environ:
  opts.Add('ldflags', 'additional linker flags', os.environ['LDFLAGS'])
else:
  opts.Add('ldflags', 'additional linker flags', '')

if 'CHOST' in os.environ:
  opts.Add('targetCHOST', 'target CHOST', os.environ['CHOST'])
else:
  opts.Add('targetCHOST', 'additional linker flags',
    ARGUMENTS.get('arch', os.uname()[4].lower()) + '-' +
    ARGUMENTS.get('computerVendor', 'unknown') + '-' +
    ARGUMENTS.get('ostype', os.uname()[0].lower()) + '-' +
    ARGUMENTS.get('cctype', 'gnu'))


env = Environment(options = opts)
env.Append (CFLAGS = env['cflags'])
env.Append (LINKFLAGS = env['ldflags'])

Help(opts.GenerateHelpText(env))

debug           = env['debug']
optimise        = env['optimise']
optimiseLinking = env['optimiseLinking']
useAssembly     = env['useAssembly']

debugMemory     = env['debugMemory']

# ACTUAL SCRIPT

arch            = env['arch']
computerVendor  = env['computerVendor']
ostype          = env['ostype']
cctype          = env['cctype']

pkgconfigpath = '/usr/lib/pkgconfig/'
# os.environ['PKG_CONFIG_PATH']

##############
try:
  os.mkdir ('build')
  print ('build directory created')
except:
  print ('build directory existed')

def normalise(str):
  return str.replace(' ', '').replace('_', '-')

paths = [ normalise(ostype + '/' + computerVendor + '/' + arch + '/' + cctype + '/'),
          normalise(ostype + '/' + arch + '/' + cctype + '/'),
          normalise(ostype + '/' + arch + '/'),
          normalise(ostype + '/' + cctype + '/'),
          normalise(ostype + '/'),
          normalise(arch + '/' + cctype + '/'),
          normalise(arch + '/'),
          normalise('posix/' + arch + '/' + cctype + '/'),
          normalise('posix/' + arch + '/'),
          normalise('posix/' + cctype + '/'),
          normalise('posix/'),
          normalise(cctype + '/'),
          'generic/' ]

if debugMemory:
  useAssembly = False
  debug = True
  paths = [ 'valgrind/' ] + paths;

if debug:
  optimiseLinking = False
  optimise = False
  paths = [ 'debug/' ] + paths;

print 'max path: ' + normalise(ostype + '/' + arch + '/' + cctype + '/');

codepreference = []
codepreferencenoasm = [ 'c' ]

if useAssembly:
  codepreference = [ 'S', 's' ]

codepreference += codepreferencenoasm

def fileexists(name):
  try:
    os.stat(name)
    return True
  except:
    return False


def haveasm(name):
  global paths, useAssembly, noasm

  if not useAssembly:
    return False

  if name in noasm:
    return False

  for i in paths:
    if fileexists('src/' + i + name + '.S') or fileexists('src/' + i + name + '.s'):
      return True

  return False

def findsource(name):
  global codepreference, paths, noasm
  for l in paths:
    if name in noasm:
      for i in codepreferencenoasm:
        n = 'src/' + l + name + '.' + i
        if fileexists(n):
          return n
    else:
      for i in codepreference:
        n = 'src/' + l + name + '.' + i
        if fileexists(n):
          return n

  return False

def writepkgconfig():
  return False

def standalone():
  global needforstandalone

  result = True

  for i in needforstandalone:
    if not haveasm(i):
      print 'missing assembly code: ' + i
      result = False
    else:
      print 'have assembly code: ' + i

  return result

for i in paths:
  if fileexists('include/' + i):
    env.Append (CPPPATH = '#include/' + i)

env.Append(LIBPATH = '.', CFLAGS='--std=c99 -Wall -pedantic')

if debug:
  env.Append(CFLAGS='-g')

if optimise:
  env.Append(CFLAGS='-O2', LINKFLAGS='-Wl,-s')

if optimiseLinking:
  env.Append(LINKFLAGS='-Wl,-x -Wl,--gc-sections -Wl,--sort-common')
  if ostype != 'darwin':
    env.Append(LINKFLAGS='-Wl,-z,noexecstack -Wl,-z,norelro')

ienv = env.Clone()

if standalone():
  print 'adjusting linker flags for using assembly atomic-libc'
  env.Append(CFLAGS = '-ffreestanding',
             LINKFLAGS = '-static -nostdlib -nostartfiles -nodefaultlibs -u _start')

  if ostype == 'darwin':
    env.Append(CFLAGS = '-static',
               LINKFLAGS = '-e _start')

else:
  print 'adjusting linker flags for using host-libc based atomic-libc'
  noasm += [ 'bootstrap' ]

# adjust linker/compiler flags in pkgconfig file

file = open('./atomic-libc.pc', "r")

lines = file.readlines()

file.close()

file = open('./build/atomic-libc.pc', "w")

mod = []
for l in lines:
  s = ""
  if "Libs:" in l:
    s = 'Libs: -latomic ' + str(env['LINKFLAGS'])  + '\n'
  elif "Cflags" in l:
    s = 'Cflags: ' + str(env['CFLAGS']) + '\n'
  else:
    s = str(l)
  file.write(s)

file.close()


sf = []

for i in sourcefiles:
  sf += [ findsource(i) ]
  if haveasm(i):
    n = findsource(i + '-highlevel');
    if n:
      sf += [ n ]

env.StaticLibrary('atomic', sf)

import glob
testsource = glob.glob('tests/*.c');

tenv = env.Clone()
tenv.Append(LIBS = ['atomic'])

penv = ienv.Clone()
penv.Append(LIBS = ['atomic'])

for i in testsource:
  tenv.Program(i)

infosource = glob.glob('information/*.c');
for i in infosource:
  ienv.Program(i)

foo = tenv.Program ('benchmarks/configure.c')

infosource = glob.glob('benchmarks/posix-*.c');
for i in infosource:
  penv.Program(i)

infosource = glob.glob('benchmarks/atomic-*.c');
for i in infosource:
  tenv.Program(i)


env.Install(pkgconfigpath, 'build/atomic-libc.pc')	
env.Alias('pkg-config', pkgconfigpath)

env.Alias('install', [ 'pkg-config' ])
