import os, glob

# LIBRARY FILES
sourcefiles = [ 'sexpr', 'io', 'memory-pool', 'tree', 'exec', 'multiplex',
                'string', 'memory-allocator', 'sexpr-library',
                'sexpr-read-write', 'network', 'multiplex-io',
                'multiplex-sexpr', 'multiplex-process', 'multiplex-signal',
                'immutable', 'graph' ]

sourcefilespp = [ 'memory++', 'io++' ]

needforstandalone = [ 'io-system', 'memory', 'bootstrap', 'network-system',
                      'exec-system', 'multiplex-system', 'signal-system' ]

installheaders = [ 'curie/exec', 'curie/main', 'curie/sexpr', 'curie/memory',
                   'curie/multiplex', 'curie/signal', 'curie/tree',
                   'curie/network', 'curie/int', 'curie/io',
                   'curie/immutable', 'curie/constants' ]

installheaderspp = [ 'curie++/int', 'curie++/io', 'curie++/multiplex' ]

sourcefiles += needforstandalone
noasm = []

# OPTIONS

opts = Options()
opts.Add(BoolOption('debug', 'build with debug information', False))
opts.Add(BoolOption('debugMemory', 'use alternative code fragments that will work with valgrind', False))
opts.Add(BoolOption('optimise', 'default optimisations', True))
opts.Add(BoolOption('optimiseLinking', 'special linker optimisations', True))
opts.Add(BoolOption('useAssembly', 'use assembler code (usually to bypass the default C library)', True))


opts.Add(BoolOption('hosted', 'avoid the standalone components', False))

opts.Add('libdir', 'libdir base name (i.e. lib, lib32, lib64, etc)', 'lib')
opts.Add('prefix', 'prefix (static libs are fine in /usr)', '/usr/')
opts.Add('destdir', 'extra installation prefix', '')

if 'CFLAGS' in os.environ:
  opts.Add('cflags', 'additional compiler flags', os.environ['CFLAGS'])
else:
  opts.Add('cflags', 'additional compiler flags', '')

if 'CXXFLAGS' in os.environ:
  opts.Add('cxxflags', 'additional compiler flags', os.environ['CXXFLAGS'])
else:
  opts.Add('cxxflags', 'additional compiler flags', '')

if 'LDFLAGS' in os.environ:
  opts.Add('ldflags', 'additional linker flags', os.environ['LDFLAGS'])
else:
  opts.Add('ldflags', 'additional linker flags', '')

if 'CHOST' in os.environ:
  pfx = os.environ['CHOST']
else:
  pfx = ARGUMENTS.get('arch', os.uname()[4].lower()) + '-' +\
        ARGUMENTS.get('computerVendor', 'unknown') + '-' +\
        ARGUMENTS.get('ostype', os.uname()[0].lower()) + '-' +\
        ARGUMENTS.get('cctype', 'gnu')

opts.Add('targetCHOST', 'target CHOST', pfx)

env = Environment(options = opts)

opts.Add('compilerPrefix', 'compiler prefix (usually the same as targetCHOST)', env['targetCHOST'])
opts.Update(env)

env.Append (CFLAGS = env['cflags'])
env.Append (CXXFLAGS = env['cxxflags'])
env.Append (LINKFLAGS = env['ldflags'])

Help(opts.GenerateHelpText(env))

debug           = env['debug']
optimise        = env['optimise']
optimiseLinking = env['optimiseLinking']
useAssembly     = env['useAssembly']

debugMemory     = env['debugMemory']

# ACTUAL SCRIPT

x = env['targetCHOST'].split('-')

arch            = x[0]
computerVendor  = x[1]
ostype          = x[2]
cctype          = x[3]

def scanexec(file):
#  return os.spawnlp(os.P_WAIT, file, file, '--version') == 0
  f = os.popen(file + ' --version 2>&1', 'r')
  if f:
    if f.close() == None:
      print 'have ' + file
      return True

  print 'missing ' + file
  return False

if scanexec (env['compilerPrefix'] + '-gcc'):
  env['CC'] = env['compilerPrefix'] + '-gcc';
  env['LINK'] = env['compilerPrefix'] + '-gcc';

if scanexec (env['compilerPrefix'] + '-g++'):
  env['CXX'] = env['compilerPrefix'] + '-g++';

if scanexec (env['compilerPrefix'] + '-as'):
  env['AS'] = env['compilerPrefix'] + '-as';

if scanexec (env['compilerPrefix'] + '-ar'):
  env['AR'] = env['compilerPrefix'] + '-ar';

if scanexec (env['compilerPrefix'] + '-ranlib'):
  env['RANLIB'] = env['compilerPrefix'] + '-ranlib';

# install directories

libdir          = env['destdir'] + env['prefix'] + env['libdir'] + '/'
pkgconfigpath   = libdir + 'pkgconfig/'
includedir      = env['destdir'] + env['prefix'] + 'include/curie/'
includedirpp    = env['destdir'] + env['prefix'] + 'include/curie++/'
# os.environ['PKG_CONFIG_PATH']

##############
try:
  os.mkdir ('build')
  print ('build directory created')
except:
  print ('build directory existed')

def normalise(str):
  return str.replace(' ', '').replace('_', '-')


def pathPermutateVendor(prefix):
  global computerVendor
  return [ normalise(prefix + computerVendor + '/'),
           normalise(prefix) ]

def pathPermutateCC(prefix):
  global cctype
  x = pathPermutateVendor(prefix + cctype + '/')
  if cctype == 'uclibc':
    x += pathPermutateVendor(prefix + 'gnu/')
  if cctype == 'dietlibc':
    x += pathPermutateVendor(prefix + 'gnu/')
  x += pathPermutateVendor(prefix)

  return x

def pathPermutateArch(prefix):
  global arch
  return pathPermutateCC(prefix + arch + '/') +\
         pathPermutateCC(prefix)

def pathPermutateOS(prefix):
  global ostype
  return pathPermutateArch(prefix + ostype + '/') +\
         pathPermutateArch(prefix) +\
         pathPermutateArch(prefix + 'posix/') +\
         pathPermutateArch(prefix + 'generic/')

def pathPermutateValgrind(prefix):
  global debugMemory
  if debugMemory:
    return pathPermutateOS(prefix + 'valgrind/') + pathPermutateOS(prefix)
  else:
    return pathPermutateOS(prefix)

def pathPermutateDebug():
  global debug
  if debug:
    return pathPermutateValgrind('debug/') + \
           pathPermutateValgrind('internal/') + \
           pathPermutateValgrind('')
  else:
    return pathPermutateValgrind('internal/') + \
           pathPermutateValgrind('')

def pathPermutate():
  return pathPermutateDebug()

if debugMemory:
  useAssembly = False
  debug = True

if debug:
  optimiseLinking = False
  optimise = False

paths = pathPermutate()

print 'max path: ' + normalise(ostype + '/' + arch + '/' + cctype + '/' + computerVendor + '/');

codepreference = []
codepreferencenoasm = [ 'c', 'c++' ]

if useAssembly:
  codepreference = [ 'S', 's' ]

codepreference += codepreferencenoasm

def fileexists(name):
  try:
    os.stat(name)
    return True
  except:
    return False

def haveasm(name):
  global paths, useAssembly, noasm

  if not useAssembly:
    return False

  if name in noasm:
    return False

  for i in paths:
    if fileexists('src/' + i + name + '.S') or fileexists('src/' + i + name + '.s'):
      return True

  return False

def findsource(name):
  global codepreference, paths, noasm
  for l in paths:
    if name in noasm:
      for i in codepreferencenoasm:
        n = 'src/' + l + name + '.' + i
        if fileexists(n):
          return n
    else:
      for i in codepreference:
        n = 'src/' + l + name + '.' + i
        if fileexists(n):
          return n

  return False

def findheader(name):
  global paths
  for l in paths:
    n = 'include/' + l + name + '.h'
    if fileexists(n):
      return n

  return False

def writepkgconfig():
  return False

def standalone():
  global needforstandalone

  result = True

  for i in needforstandalone:
    if not haveasm(i):
      print 'missing assembly code: ' + i
      result = False
    else:
      print 'have assembly code: ' + i

  return result

for i in paths:
  if fileexists('include/' + i):
    env.Append (CPPPATH = [ '#include/' + i ])

env.Append(LIBPATH = '.',
           CFLAGS='--std=c99 -Wall -pedantic',
           CXXFLAGS='-Wall -fno-exceptions')

if debug:
  env.Append(CFLAGS='-g')

if optimise:
  env.Append(CFLAGS='-O2', LINKFLAGS='-Wl,-s')

if optimiseLinking:
  env.Append(LINKFLAGS='-Wl,-x')

  if ostype == 'linux':
    env.Append(LINKFLAGS='-Wl,-z,noexecstack -Wl,-z,norelro -Wl,--gc-sections -Wl,--sort-common')

ienv = env.Clone()

cflagsx=''
linkx=''

if standalone() and not env['hosted']:
  print 'linker configuration: freestanding'
  cflagsx += '-ffreestanding'
  linkx   += '-static -nostdlib -nostartfiles -nodefaultlibs -u _start'

  if ostype == 'darwin':
    cflagsx += '-static'
    linkx   += '-e _start'

else:
  print 'linker configuration: hosted'
  noasm += [ 'bootstrap' ]
  if not env['hosted']:
    cflagsx += '-ffreestanding'
    linkx   += '-nodefaultlibs -lc'

if env['hosted']:
  sourcefiles.remove ('bootstrap');

env.Append(CFLAGS = cflagsx,
           LINKFLAGS = linkx)

# adjust linker/compiler flags in pkgconfig file

file = open('./libcurie.pc', "r")

lines = file.readlines()

file.close()

if env['hosted']:
  file = open('./build/libcurie-hosted.pc', "w")
else:
  file = open('./build/libcurie.pc', "w")

mod = []
for l in lines:
  s = ""
  if "Libs:" in l:
    if env['hosted']:
      s = 'Libs: -lcurie-hosted ' + linkx  + '\n'
    else:
      s = 'Libs: -lcurie ' + linkx  + '\n'
  elif "Cflags" in l:
    s = 'Cflags: ' + cflagsx + '\n'
  else:
    s = str(l)
  file.write(s)

file.close()

#### actual compilation bit

sf = []

for i in sourcefiles:
  sf += [ findsource(i) ]
  if haveasm(i):
    n = findsource(i + '-highlevel');
    if n:
      sf += [ n ]

if env['hosted']:
  x = env.StaticLibrary('curie-hosted', sf)
else:
  x = env.StaticLibrary('curie', sf)

env.Alias ('library', x)
env.Install (libdir, x)

sf = []

for i in sourcefilespp:
  sf += [ findsource(i) ]
  if haveasm(i):
    n = findsource(i + '-highlevel');
    if n:
      sf += [ n ]

x = env.StaticLibrary('curie++', sf)
env.Alias ('library++', x)
env.Install (libdir, x)

# test cases, etc

if env['hosted']:
  env.Install(pkgconfigpath, [ 'build/libcurie-hosted.pc',
                               'libcurie++-hosted.pc'])

  env.Alias('install', [ pkgconfigpath, libdir ])
else:
  testsource = glob.glob('tests/*.c');
  testsourcepp = glob.glob('tests/*.c++');

  tenv = env.Clone()
  tenv.Append(LIBS = ['curie'])

  tppenv = tenv.Clone()
  tppenv.Append(LIBS = ['curie++'])

  penv = ienv.Clone()
  penv.Append(LIBS = ['curie'])

  for i in testsource:
    tenv.Program(i)

  for i in testsourcepp:
    tppenv.Program(i)

  infosource = glob.glob('information/*.c');
  for i in infosource:
    ienv.Program(i)

  foo = tenv.Program ('benchmarks/configure.c')

  infosource = glob.glob('benchmarks/posix-*.c');
  for i in infosource:
    penv.Program(i)

  infosource = glob.glob('benchmarks/curie-*.c');
  for i in infosource:
    tenv.Program(i)


  for i in installheaders:
    x = findheader(i)
    if x:
      env.Install (includedir, x);

  for i in installheaderspp:
    x = findheader(i)
    if x:
      env.Install (includedirpp, x);

  env.Install(pkgconfigpath, [ 'build/libcurie.pc', 'libcurie++.pc' ])

  env.Alias('install', [ pkgconfigpath, libdir, includedir, includedirpp ])
